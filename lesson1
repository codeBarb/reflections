Q - How did viewing a diff between two versions of a file help you see the bug that was introduced?

It was helpful. Easy to see.

Instructions on how to launch it:

1. Launch terminal
2. Navigate to directory with files
3. Diff -u file_old.js file_new.js (order is important here otherwise you reverse result)
4. read the output; - is what is no longer in the new file; + is what is new in the new file


//
Version control saving.

How would you design a new version control systsm.
-  When would you want to have a version of your code saved.

//
 What do you think are the pros and cons of
manually choosing when to create a commit,
like you do in Git, vs having versions automatically saved,
like Google docs does?
>> automatic committs may create lots of little files with insignificant changes
>> in manual committs, it may be too many changes at once, but it gives you more control

//
Why do you think some version control systems,
like Git, allow saving multiple files in one commit,
while others, like Google Docs, treat each file separately?
 >> Seems like when you are coding, you have a separation of
 concerns into differnet files. Some changes can affect all
 files so they need to be saved simultaneously in one commit.

//
How can you use the commands git log and git diff to view the history of files?

>> git log: shows you all the committs for the file you're asking.
Ex. git log game.js
>> git diff: shows the differences b/w 2 committs based on the commit ID.
Each commit has it's own ID.
Ex. git diff 12345 1234566

//
How might using version control make you more confident
 to make changes that could break something?
>> It is easy to revert to older versions, and use git diff to see what exactly
had changed between successive commits.

//

How can you use the staging area to make sure you have one commit per logical change?
>> I can add as many or as few files as I want and then commit the staging
area at one time. Helps keep track of work, but also allows flex to submit when ready.


//
What are some situations when branches would be helpful
in keeping your history organized? How would branches help?
>> When working with different people you can each work on a feature branch;
>> When you don't want to mess up the master, and experiment with different sets for perhaps usertesting.

//

How do the diagrams help you visualize the branch structure?
>> helps you visualize what code you're working on and what will/won't be part of the change.

//

What is the result of merging two branches together?
 Why do we represent it in the diagram the way we do?
>> Bringing in the new features/changes from the branch into the master branch.
>> Helps programmer vizualize at what commit changes were added.

//

What are the pros and cons of Gitâ€™s automatic merging vs. always doing merges manually?
>> Pros of automatic v. manual merging: simplifies the commit; good for minor & obvious changes
>> Cons of automatic v. manual merging: not good when you've re-written functions better for instance;
 the user would need to determine which should be better




